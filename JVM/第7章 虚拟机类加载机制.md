[TOC]

## 7.1 什么是类加载机制

&emsp;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

&emsp;类型（类或接口等）的加载、连接和初始化过程都是在**程序运行期间完成**的

## 7.2 类加载的时机

&emsp;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7个阶段。其中验证、准备、解析3个部分统称为连接

![类的生命周期](D:\PersonalNote\JVM\images\类的生命周期.png)

&emsp;**加载、验证、准备、初始化这卸载这5个阶段的顺序是确定的**，而解析阶段则不一定，他在某些情况下可以在初始化之后在开始，这时为了支持Java语言的运行时绑定（动态绑定）

&emsp;什么情况下开始第一个阶段：加载，在Java虚拟机规范中并没有强制约束，可以交由虚拟机的具体实现来自由把握，但是对于**初始化阶段**，虚拟机规范严格规定了**有且只有**5种情况必须立即对类进行**初始化**：

* 遇到new、getstatic、putstatic、invokestatic这4个字节码指令时，如果类没有初始化，则需要先出发其初始化
* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化
* 当初始化一个类的时候，如果发现其父类没有被初始化则需要先初始化它的父类
* 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个主类
* 使用Jdk1.7动态语言支持的时候的一些情况。如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄时，对应的类没有初始化，需要初始化

&emsp;**这5中场景称为对一个类进行主动引用，除此之外，所有引用类的方式都不会出发初始化，称为被动引用**

&emsp;**接口的初始化和类的初始化区别在于第三点，当一个接口初始化时，不要求其父接口全部都完成了初始化，只有在真正使用到父接口时（如引用接口中定义的常量）才会初始化**

## 7.3 类加载的过程

&emsp;类加载的全过程就是：**加载、验证、准备、解析、初始化**5个阶段所执行的具体动作

### 7.3.1 加载

&emsp;加载是类加载过程的第一个阶段，在此阶段，虚拟机需要完成三件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

&emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式**存储在方法区**（方法区中的数据存储格式由虚拟机实现自行定义）。然后在内存（方法区）中实例化一个java.lang.Class类对象

### 7.3.2 验证

&emsp;验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

&emsp;主要包括4个阶段验证：

1. 文件格式验证

   保证输入的字节流能正确的解析并存储于方法区中

2. 元数据验证

   对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范

3. 字节码验证

   最复杂的一个阶段，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的

4. 符号引用验证

   此验证发生在解析阶段中，目的是确保解析动作能正常执行，如果无法通过符号引用验证，则会抛出java.lang.IncompatibleClassChangeError异常的子类

&emsp;**验证阶段是一个非常重要但不一定必要的阶段，如果所运行的全部代码已经被反复使用和验证过，那么可以使用-Xverify:none参数来关闭类验证措施，以缩短虚拟机类加载时间**

### 7.3.3 准备

&emsp;此阶段是在**方法区**中正式为**类变量（static修饰的变量）**分配内存并设置**类变量初始值**的阶段

&emsp;类变量初始值是指数据类型的零值，例如：

* public static int value = 123;

  此阶段value的值是0而不是123，赋值操作是在初始化阶段才执行的

  如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123

<center>基本数据类型零值</center>
| 数据类型 | 零值     | 数据类型  | 零值  |
| :------: | -------- | --------- | ----- |
|   int    | 0        | boolean   | false |
|   long   | 0L       | float     | 0.0f  |
|  short   | (short)0 | double    | 0.0d  |
|   char   | '\u0000' | reference | null  |
|   byte   | (byte)0  |           |       |

### 7.3.4 解析

* 解析阶段是虚拟机将**常量池**内的符号引用替换为直接引用的过程。
* 解析动作**主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行**。

### 7.3.5 初始化

&emsp;**只有前面提到的5中主动引用才会触发初始化**

* 初始化阶段就是执行类构造器方法<clinit>()的过程
* **此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来**
* 赋值动作会按源文件中语句出现的顺序执行
* <clinit>()不同于类的构造器（即实例构造器<init>()方法），他**不需要显式地调用父类构造器**，**如果该类有父类，虚拟机会保证在子类<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕**
* **如果一个类没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法**
* **没有静态语句块，只有赋值操作，仍会生成<clinit>()方法，只是执行接口的<clinit>()方法时不会执行父接口的<clinit>()方法，只有当父接口中定义的变量使用时才会执行父接口的<clinit>()方法，另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法**
* 虚拟机必须保证一个类的<clinit>()方法在多线程下被加锁、同步

## 7.4 类加载器

&emsp;虚拟机将加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作放到了虚拟机外部去实现，以便让程序自己决定如何去获取需要的类，实现这个动作的代码模块称为“类加载器”

### 7.4.1 类与类加载器

&emsp;类加载器虽然只用于实现加载动作，但他还有其他作用：**对于任意一个类，都需要有架在她的类加载器和这个类本身一同确立其在java虚拟机中的唯一性。**

&emsp;通俗来说就是比较两个类是否“相等”，这里的“相等”指Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果以及instanceof关键字的判定结果

### 7.4.2 双亲委派模型

&emsp;从Java虚拟机角度讲，只存在两种不同的类加载器

* 启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机自身的一部分
* 所有其他的类加载器，由java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader

&emsp;从开发人员角度讲，类加载器可以划分的细致些，绝大部分java程序都会用到以下3种**系统提供的类加载器**

* 启动类加载器（Bootstrap ClassLoader）

  负责将<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别）类库加载到虚拟机内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以 **不允许直接通过引用进行操作。**

* 扩展类加载器（Extension ClassLoader）

  扩展类加载器是由sun.misc.Launcher$ExtClassLoader实现的，它负责将JAVA_HOME /lib/ext或者由系统变量java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用扩展类加载器

* 应用程序类加载器（Application ClassLoader）

  由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也被称作系统类加载器

  由 sun.misc.Launcher$AppClassLoader实现，它负责加载用户类路径(ClassPath)上所指定的类库，程序员可以直接使用这个类加载器。**如果程序中没有自定义类加载器，那么这个就是程序默认的类加载器**

&emsp;应用程序都是由这3种类加载器配合进行加载的，如果有必要还可以加入自定义的类加载器，如图所示的类加载器之间的这种层次关系成为**类加载器的双亲委派模型（Parents Delegation Model）**

![双亲委派模型](D:\PersonalNote\JVM\images\双亲委派.png)

### 7.4.3 双亲委派机制工作流程

&emsp;双亲委派模型的工作过程：

1. 一个类加载器收到了类加载请求
2. 把这个请求委派给父加载器去完成，每一个类加载器都是如此
3. 最终所有加载请求都传到顶层的启动类加载器中
4. 若父加载器无法完成这个请求时（搜索范围中没有找到需要的类），子加载器才会尝试自己去加载

&emsp;可以总结为：**自底向上检查类是否被加载，自顶向下尝试加载类**

![双亲委派](D:\PersonalNote\JVM\images\双亲委派模型.png)

> [面试官：java双亲委派机制及作用](https://www.jianshu.com/p/1e4011617650)

### 7.4.4 双亲委派机制的优势

* 避免类的重复加载
* 保护程序安全，防止核心API被随意篡改

### 7.4.5 沙箱安全机制

&emsp;沙箱安全机制是基于双亲委派机制采取的一种JVM的自我保护机制,假设要写一个java.lang.String 的类,由于双亲委派机制的原理,此请求会先交给Bootstrap试图进行加载,但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类,有则优先加载rt.jar包中的类（如果没有，一般也会报错，警告用户不能使用java.lang为包名）,因此就保证了java的运行机制不会被破坏

### 7.4.6 线程上下文加载器（破坏双亲委派机制）

&emsp;SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 SPI的作用就是为这些被扩展的API寻找服务实现，SPI有JDBC、JCE、JNDI、JAXP和JBI等。

&emsp;当用户使用JDBC时，会通过引导类加载器加载SPI核心类（就是java提供好的接口），当调用实现类中的方法时，引导类加载器就会反向委派给线程上下文加载器来加载这些实现类。这个反向委派也称为破坏双亲委派。

![SPI加载过程](D:\PersonalNote\JVM\images\SPI加载.png)

### 7.4.7 对于类加载器的引用

&emsp;如果一个类不是由启动类加载器加载的，**那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区**

